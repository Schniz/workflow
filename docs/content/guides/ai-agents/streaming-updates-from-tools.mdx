---
title: Streaming Updates from Tools
---

After [building a durable AI agent](/guides/ai-agents), we already get UI message chunks for displaying tool invocations and return values. However, for long-running steps, we may want to show progress updates, or stream step output to the user while it's being generated.

Workflow DevKit enables this by letting step functions write custom chunks to the same stream the agent uses. These chunks appear as data parts in your messages, which you can render however you like.

<Steps>

<Step>
### Define Your Data Part Type

First, define a TypeScript type for your custom data part. This ensures type safety across your tool and client code:

```typescript title="types/chat.ts" lineNumbers
export interface SearchWebDataPart {
  type: 'data-search-web'; // [!code highlight]
  id: string;
  data: {
    url: string;
    status: 'fetching' | 'done';
  };
}
```

The `type` field must be a string starting with `data-` followed by your custom identifier. The `id` field should match the `toolCallId` so the client can associate the data with the correct tool invocation.

</Step>

<Step>
### Emit Updates from Your Tool

Use [`getWritable()`](/docs/api-reference/workflow/get-writable) inside a step function to get a handle to the stream. Write your custom chunks as the tool progresses:

```typescript title="ai/tools/search-web.ts" lineNumbers
import { tool } from 'ai';
import { getWritable } from 'workflow';
import { z } from 'zod';
import type { UIMessageChunk } from 'ai';

async function executeSearch(
  { url }: { url: string },
  { toolCallId }: { toolCallId: string }
) {
  'use step';

  const writable = getWritable<UIMessageChunk>(); // [!code highlight]
  const writer = writable.getWriter();

  // Emit a progress update
  await writer.write({
    type: 'data-search-web', // [!code highlight]
    id: toolCallId, // [!code highlight]
    data: { url, status: 'fetching' },
  });

  const response = await fetch(url);
  const content = await response.text();

  await writer.write({
    type: 'data-search-web',
    id: toolCallId,
    data: { url, status: 'done' },
  });

  writer.releaseLock();

  return content;
}

export const searchWeb = tool({
  description: 'Read a web page and return the content',
  inputSchema: z.object({ url: z.string() }),
  execute: executeSearch,
});
```

Key points:

- Call `getWritable<UIMessageChunk>()` to get the stream
- Use `getWriter()` to acquire a writer
- Write objects with `type`, `id`, and `data` fields
- Always call `releaseLock()` when done writing

</Step>

<Step>
### Handle Data Parts in the Client

Update your chat component to detect and render the custom data parts. Data parts are stored in the message's `parts` array alongside text and tool invocation parts:

```typescript title="app/chat.tsx" lineNumbers
{message.parts.map((part, partIndex) => {
  // Render text parts
  if (part.type === 'text') {
    return (
      <Response key={`${message.id}-text-${partIndex}`}>
        {part.text}
      </Response>
    );
  }

  // Render tool parts with progress status // [!code highlight]
  if (part.type === 'tool-searchWeb') { // [!code highlight]
    if (!('toolCallId' in part) || !('state' in part)) {
      return null;
    }

    // Find the latest data part for this tool call // [!code highlight]
    const dataPart = message.parts.findLast( // [!code highlight]
      (p) => p.type === 'data-search-web' && p.id === part.toolCallId // [!code highlight]
    ); // [!code highlight]

    // Extract status from the data part // [!code highlight]
    const status = // [!code highlight]
      dataPart && 'data' in dataPart // [!code highlight]
        ? (dataPart.data as { status: string; url: string }) // [!code highlight]
        : null; // [!code highlight]

    return (
      <Tool key={part.toolCallId}>
        <ToolHeader type={part.type} state={part.state} />
        <ToolContent>
          {status?.status === 'fetching' && ( // [!code highlight]
            <div className="text-muted-foreground text-sm"> // [!code highlight]
              Fetching {status.url}... // [!code highlight]
            </div> // [!code highlight]
          )} // [!code highlight]
          {part.state === 'output-available' && (
            <ToolOutput output={renderToolOutput(part)} />
          )}
        </ToolContent>
      </Tool>
    );
  }

  return null;
})}
```

The pattern is:

1. When rendering a tool invocation part, search for matching data parts using `findLast()`
2. Match by comparing the data part's `id` to the tool's `toolCallId`
3. Use the data part's payload to display progress or intermediate results

</Step>

</Steps>

## Related Documentation

- [Building Durable AI Agents](/guides/ai-agents) - Complete guide to durable agents
- [`getWritable()` API Reference](/docs/api-reference/workflow/get-writable) - Stream API details
- [Streaming](/docs/foundations/streaming) - Understanding workflow streams
